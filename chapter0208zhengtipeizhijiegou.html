<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>深入浅出Webpack-整体配置结构</title>
<link href="main.css" rel="stylesheet">
</head>
<body>
    <h1 id="2-8-整体配置结构">2-8 整体配置结构</h1>
    <p>之前的章节分别讲述了每个配置项的具体含义，但没有描述它们所处的位置和数据结构，下面通过一份代码来描述清楚：</p>
    <pre><code class="lang-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

    <span class="hljs-built_in">module</span>.exports = {
      <span class="hljs-comment">// entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</span>
      <span class="hljs-comment">// 类型可以是 string | object | array   </span>
      entry: <span class="hljs-string">'./app/entry'</span>, <span class="hljs-comment">// 只有1个入口，入口只有1个文件</span>
      entry: [<span class="hljs-string">'./app/entry1'</span>, <span class="hljs-string">'./app/entry2'</span>], <span class="hljs-comment">// 只有1个入口，入口有2个文件</span>
      entry: { <span class="hljs-comment">// 有2个入口</span>
        a: <span class="hljs-string">'./app/entry-a'</span>,
        b: [<span class="hljs-string">'./app/entry-b1'</span>, <span class="hljs-string">'./app/entry-b2'</span>]
      },

      <span class="hljs-comment">// 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。</span>
      output: {
        <span class="hljs-comment">// 输出文件存放的目录，必须是 string 类型的绝对路径。</span>
        path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),

        <span class="hljs-comment">// 输出文件的名称</span>
        filename: <span class="hljs-string">'bundle.js'</span>, <span class="hljs-comment">// 完整的名称</span>
        filename: <span class="hljs-string">'[name].js'</span>, <span class="hljs-comment">// 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称</span>
        filename: <span class="hljs-string">'[chunkhash].js'</span>, <span class="hljs-comment">// 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件</span>

        <span class="hljs-comment">// 发布到线上的所有资源的 URL 前缀，string 类型</span>
        publicPath: <span class="hljs-string">'/assets/'</span>, <span class="hljs-comment">// 放到指定目录下</span>
        publicPath: <span class="hljs-string">''</span>, <span class="hljs-comment">// 放到根目录下</span>
        publicPath: <span class="hljs-string">'https://cdn.example.com/'</span>, <span class="hljs-comment">// 放到 CDN 上去</span>

        <span class="hljs-comment">// 导出库的名称，string 类型</span>
        <span class="hljs-comment">// 不填它时，默认输出格式是匿名的立即执行函数</span>
        library: <span class="hljs-string">'MyLibrary'</span>,

        <span class="hljs-comment">// 导出库的类型，枚举类型，默认是 var</span>
        <span class="hljs-comment">// 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ，</span>
        libraryTarget: <span class="hljs-string">'umd'</span>, 

        <span class="hljs-comment">// 是否包含有用的文件路径信息到生成的代码里去，boolean 类型</span>
        pathinfo: <span class="hljs-literal">true</span>, 

        <span class="hljs-comment">// 附加 Chunk 的文件名称</span>
        chunkFilename: <span class="hljs-string">'[id].js'</span>,
        chunkFilename: <span class="hljs-string">'[chunkhash].js'</span>,

        <span class="hljs-comment">// JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用</span>
        jsonpFunction: <span class="hljs-string">'myWebpackJsonp'</span>,

        <span class="hljs-comment">// 生成的 Source Map 文件名称</span>
        sourceMapFilename: <span class="hljs-string">'[file].map'</span>,

        <span class="hljs-comment">// 浏览器开发者工具里显示的源码模块名称</span>
        devtoolModuleFilenameTemplate: <span class="hljs-string">'webpack:///[resource-path]'</span>,

        <span class="hljs-comment">// 异步加载跨域的资源时使用的方式</span>
        crossOriginLoading: <span class="hljs-string">'use-credentials'</span>,
        crossOriginLoading: <span class="hljs-string">'anonymous'</span>,
        crossOriginLoading: <span class="hljs-literal">false</span>,
      },

      <span class="hljs-comment">// 配置模块相关</span>
      <span class="hljs-built_in">module</span>: {
        rules: [ <span class="hljs-comment">// 配置 Loader</span>
          {  
            test: <span class="hljs-regexp">/\.jsx?$/</span>, <span class="hljs-comment">// 正则匹配命中要使用 Loader 的文件</span>
            include: [ <span class="hljs-comment">// 只会命中这里面的文件</span>
              path.resolve(__dirname, <span class="hljs-string">'app'</span>)
            ],
            exclude: [ <span class="hljs-comment">// 忽略这里面的文件</span>
              path.resolve(__dirname, <span class="hljs-string">'app/demo-files'</span>)
            ],
            use: [ <span class="hljs-comment">// 使用那些 Loader，有先后次序，从后往前执行</span>
              <span class="hljs-string">'style-loader'</span>, <span class="hljs-comment">// 直接使用 Loader 的名称</span>
              {
                loader: <span class="hljs-string">'css-loader'</span>,      
                options: { <span class="hljs-comment">// 给 html-loader 传一些参数</span>
                }
              }
            ]
          },
        ],
        noParse: [ <span class="hljs-comment">// 不用解析和处理的模块</span>
          /special-library\.js$/  <span class="hljs-comment">// 用正则匹配</span>
        ],
      },

      <span class="hljs-comment">// 配置插件</span>
      plugins: [
      ],

      <span class="hljs-comment">// 配置寻找模块的规则</span>
      resolve: { 
        modules: [ <span class="hljs-comment">// 寻找模块的根目录，array 类型，默认以 node_modules 为根目录</span>
          <span class="hljs-string">'node_modules'</span>,
          path.resolve(__dirname, <span class="hljs-string">'app'</span>)
        ],
        extensions: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.json'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.css'</span>], <span class="hljs-comment">// 模块的后缀名</span>
        alias: { <span class="hljs-comment">// 模块别名配置，用于映射模块</span>
           <span class="hljs-comment">// 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file'</span>
          <span class="hljs-string">'module'</span>: <span class="hljs-string">'new-module'</span>,
          <span class="hljs-comment">// 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'，</span>
          <span class="hljs-comment">// 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file'</span>
          <span class="hljs-string">'only-module$'</span>: <span class="hljs-string">'new-module'</span>, 
        },
        alias: [ <span class="hljs-comment">// alias 还支持使用数组来更详细的配置</span>
          {
            name: <span class="hljs-string">'module'</span>, <span class="hljs-comment">// 老的模块</span>
            alias: <span class="hljs-string">'new-module'</span>, <span class="hljs-comment">// 新的模块</span>
            <span class="hljs-comment">// 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射</span>
            onlyModule: <span class="hljs-literal">true</span>, 
          }
        ],
        symlinks: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否跟随文件软链接去搜寻模块的路径</span>
        descriptionFiles: [<span class="hljs-string">'package.json'</span>], <span class="hljs-comment">// 模块的描述文件</span>
        mainFields: [<span class="hljs-string">'main'</span>], <span class="hljs-comment">// 模块的描述文件里的描述入口的文件的字段名称</span>
        enforceExtension: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否强制导入语句必须要写明文件后缀</span>
      },

      <span class="hljs-comment">// 输出文件性能检查配置</span>
      performance: { 
        hints: <span class="hljs-string">'warning'</span>, <span class="hljs-comment">// 有性能问题时输出警告</span>
        hints: <span class="hljs-string">'error'</span>, <span class="hljs-comment">// 有性能问题时输出错误</span>
        hints: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 关闭性能检查</span>
        maxAssetSize: <span class="hljs-number">200000</span>, <span class="hljs-comment">// 最大文件大小 (单位 bytes)</span>
        maxEntrypointSize: <span class="hljs-number">400000</span>, <span class="hljs-comment">// 最大入口文件大小 (单位 bytes)</span>
        assetFilter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">assetFilename</span>) </span>{ <span class="hljs-comment">// 过滤要检查的文件</span>
          <span class="hljs-keyword">return</span> assetFilename.endsWith(<span class="hljs-string">'.css'</span>) || assetFilename.endsWith(<span class="hljs-string">'.js'</span>);
        }
      },

      devtool: <span class="hljs-string">'source-map'</span>, <span class="hljs-comment">// 配置 source-map 类型</span>

      context: __dirname, <span class="hljs-comment">// Webpack 使用的根目录，string 类型必须是绝对路径</span>

      <span class="hljs-comment">// 配置输出代码的运行环境</span>
      target: <span class="hljs-string">'web'</span>, <span class="hljs-comment">// 浏览器，默认</span>
      target: <span class="hljs-string">'webworker'</span>, <span class="hljs-comment">// WebWorker</span>
      target: <span class="hljs-string">'node'</span>, <span class="hljs-comment">// Node.js，使用 `require` 语句加载 Chunk 代码</span>
      target: <span class="hljs-string">'async-node'</span>, <span class="hljs-comment">// Node.js，异步加载 Chunk 代码</span>
      target: <span class="hljs-string">'node-webkit'</span>, <span class="hljs-comment">// nw.js</span>
      target: <span class="hljs-string">'electron-main'</span>, <span class="hljs-comment">// electron, 主线程</span>
      target: <span class="hljs-string">'electron-renderer'</span>, <span class="hljs-comment">// electron, 渲染线程</span>

      externals: { <span class="hljs-comment">// 使用来自 JavaScript 运行环境提供的全局变量</span>
        jquery: <span class="hljs-string">'jQuery'</span>
      },

      stats: { <span class="hljs-comment">// 控制台输出日志控制</span>
        assets: <span class="hljs-literal">true</span>,
        colors: <span class="hljs-literal">true</span>,
        errors: <span class="hljs-literal">true</span>,
        errorDetails: <span class="hljs-literal">true</span>,
        hash: <span class="hljs-literal">true</span>,
      },

      devServer: { <span class="hljs-comment">// DevServer 相关的配置</span>
        proxy: { <span class="hljs-comment">// 代理到后端服务接口</span>
          <span class="hljs-string">'/api'</span>: <span class="hljs-string">'http://localhost:3000'</span>
        },
        contentBase: path.join(__dirname, <span class="hljs-string">'public'</span>), <span class="hljs-comment">// 配置 DevServer HTTP 服务器的文件根目录</span>
        compress: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启 gzip 压缩</span>
        historyApiFallback: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开发 HTML5 History API 网页</span>
        hot: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启模块热替换功能</span>
        https: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否开启 HTTPS 模式</span>
        },

        profile: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳</span>

        cache: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否启用缓存提升构建速度</span>

        watch: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开始</span>
        watchOptions: { <span class="hljs-comment">// 监听模式选项</span>
        <span class="hljs-comment">// 不监听的文件或文件夹，支持正则匹配。默认为空</span>
        ignored: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-comment">// 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高</span>
        <span class="hljs-comment">// 默认为300ms </span>
        aggregateTimeout: <span class="hljs-number">300</span>,
        <span class="hljs-comment">// 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次</span>
        poll: <span class="hljs-number">1000</span>
      },
    }
    </code></pre>
</body>
</html>
